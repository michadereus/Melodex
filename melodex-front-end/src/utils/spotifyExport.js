// melodex-front-end/src/utils/spotifyExport.js

/** ---------- Filters ---------- **/
export function buildFilters(selection = {}) {
  const norm = (v) =>
    typeof v === "string" ? v.trim().toLowerCase() : v;

  const genre = norm(selection.genre);
  const subgenre = norm(selection.subgenre);

  // No genre & no subgenre => empty
  if (!genre && !subgenre) return { type: "none" };

  // Subgenre without a genre => treat as empty
  if (!genre && subgenre) return { type: "none" };

  // Genre present -> build genre filter (subgenre optional)
  const out = { type: "genre", genre };
  if (subgenre) out.subgenre = subgenre;
  return out;
}

/** ---------- Mapping ---------- **/
/**
 * Map a list of ranked items (possibly Deezer-origin) to Spotify URIs.
 * Rules expected by tests:
 *  - Prefer ISRC lookup when available
 *  - Fallback to title+artist search (normalized to lower-case, trimmed)
 *  - Skip `removed` or `skipped` items
 *  - Deduplicate by URI, preserving first occurrence (rank order)
 *  - Return shape: { uris: string[] }
 *
 * @param {Array<Object>} items
 * @param {(q: {isrc?: string, title?: string, artist?: string}) => Promise<{uri: string} | null>} search
 */
export async function mapDeezerToSpotifyUris(items = [], search = async () => null) {
  const uris = [];
  const seen = new Set();

  const normText = (s) =>
    (s ?? "")
      .toString()
      .trim()
      .toLowerCase()
      .replace(/\s+/g, " ");

  for (const it of items) {
    if (!it || it.removed || it.skipped) continue;

    // If the item already contains a Spotify URI, use it directly
    const rawUri = it.spotifyUri || it.spotify_uri || it.uri;
    if (typeof rawUri === "string" && /^spotify:track:[A-Za-z0-9]+$/.test(rawUri.trim())) {
      const uri = rawUri.trim();
      if (!seen.has(uri)) {
        seen.add(uri);
        uris.push(uri);
      }
      continue;
    }

    // Prefer ISRC
    let found = null;
    const isrc = typeof it.isrc === "string" ? it.isrc.trim() : null;
    if (isrc) {
      found = await search({ isrc });
    }

    // Fallback to title + artist
    if (!found) {
      const title = normText(it.title);
      const artist = normText(it.artist);
      if (title && artist) {
        found = await search({ title, artist });
      }
    }

    if (found?.uri && /^spotify:track:[A-Za-z0-9]+$/.test(found.uri)) {
      if (!seen.has(found.uri)) {
        seen.add(found.uri);
        uris.push(found.uri);
      }
    }
  }

  return { uris };
}

/** ---------- Create Payload ---------- **/
/**
 * Build the final create-playlist payload.
 * Tests expect:
 *  - Defaults: name "Melodex Playlist YYYY-MM-DD", description "Generated by Melodex"
 *  - If `uris` provided, carry it through as-is (donâ€™t remap here)
 */
export function buildCreatePayload({ name, description, uris = [] } = {}) {
  const today = new Date();
  const yyyy = String(today.getFullYear());
  const mm = String(today.getMonth() + 1).padStart(2, "0");
  const dd = String(today.getDate()).padStart(2, "0");

  const defaultName = `Melodex Playlist ${yyyy}-${mm}-${dd}`;
  const safeName = (name ?? "").toString().trim() || defaultName;
  const safeDesc = (description ?? "").toString().trim() || "Generated by Melodex";

  return {
    name: safeName,
    description: safeDesc,
    uris: Array.isArray(uris) ? uris : [],
  };
}
