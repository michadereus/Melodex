// Filepath: melodex-front-end/src/components/Rankings.jsx
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useSongContext } from '../contexts/SongContext';
import { useVolumeContext } from '../contexts/VolumeContext';
import SongFilter from './SongFilter';
import '../index.css';
import { formatDefaultPlaylistName } from '../utils/formatDefaultPlaylistName';
import { buildDeepLink } from '../utils/deeplink';

// ===== Exportable helper so UI tests can import it =====
export async function ensureSpotifyConnected(authRoot = '') {
  const base = String(authRoot || '').replace(/\/+$/, '');
  try {
    const r = await fetch(`${base}/auth/session`, { credentials: 'include' });
    if (!r.ok) return { shouldRedirect: true, to: `${base}/auth/start` };
    const { connected } = await r.json();
    if (!connected) return { shouldRedirect: true, to: `${base}/auth/start` };
    return { shouldRedirect: false };
  } catch {
    return { shouldRedirect: true, to: `${base}/auth/start` };
  }
}

const Rankings = () => {
  const { rankedSongs, fetchRankedSongs, loading, userID } = useSongContext();
  const { volume, setVolume, playingAudioRef, setPlayingAudioRef } = useVolumeContext();

  const [applied, setApplied] = useState(false);
  const [enrichedSongs, setEnrichedSongs] = useState([]);
  const [filteredSongs, setFilteredSongs] = useState([]);
  const [showFilter, setShowFilter] = useState(true);
  const [isFetching, setIsFetching] = useState(false);
  const [selectedGenre, setSelectedGenre] = useState('any');
  const [selectedSubgenre, setSelectedSubgenre] = useState('any');
  const [lastAppliedFilters, setLastAppliedFilters] = useState({ genre: 'any', subgenre: 'any' });

  // Inline export selection mode
  const [selectionMode, setSelectionMode] = useState(false);
  const [selected, setSelected] = useState(new Set());
  const [playlistName, setPlaylistName] = useState(() => formatDefaultPlaylistName());
  const [playlistDescription, setPlaylistDescription] = useState('');
  const [exporting, setExporting] = useState(false);
  const [exportSuccessUrl, setExportSuccessUrl] = useState('');

  // Export progress states (idle → loading → success|error)
  const ExportState = {
    Idle: 'idle',
    Validating: 'validating',
    Creating: 'creating',
    Adding: 'adding',
    Success: 'success',
    Error: 'error',
  };
  const [exportState, setExportState] = useState(ExportState.Idle);
  const [exportError, setExportError] = useState(null);

  // Map<stableKey, HTMLAudioElement>
  const audioRefs = useRef(new Map());
  const rehydratingRef = useRef(new Set());
  const didRunFixRef = useRef(false);
  const recentlyDoneRef = useRef(new Map()); // key -> timestamp (ms)
  const autoInitRef = useRef(false);         // avoid StrictMode/HMR double-run
  const rehydrateAvailableRef = useRef(null); // null=unknown, true/false after first attempt

  const RECENTLY_DONE_WINDOW_MS = 5 * 60 * 1000;
  const isCypressEnv = typeof window !== 'undefined' && (!!window.Cypress || window.__E2E_REQUIRE_AUTH__ === false);

  // ---- API base (handles with/without trailing /api) ----
  const RAW_BASE =
    import.meta.env.VITE_API_BASE_URL ??
    import.meta.env.VITE_API_BASE ??
    window.__API_BASE__ ??
    'http://localhost:8080';

  const normalizeNoTrail = (s) => String(s).replace(/\/+$/, '');
  const baseNoTrail = normalizeNoTrail(RAW_BASE);
  const API_ROOT = /\/api$/.test(baseNoTrail) ? baseNoTrail : `${baseNoTrail}/api`;
  const AUTH_ROOT = baseNoTrail;

  const joinUrl = (...parts) =>
    parts
      .map((p, i) => (i === 0 ? String(p).replace(/\/+$/, '') : String(p).replace(/^\/+|\/+$/g, '')))
      .filter(Boolean)
      .join('/');

  function recentlyDone(key) {
    const ts = recentlyDoneRef.current.get(key) || 0;
    return Date.now() - ts < RECENTLY_DONE_WINDOW_MS;
  }

  // ===== Helpers =====
  const stableKey = (s) => {
    if (!s) return 'na__';
    if (s._id) return `id_${String(s._id)}`;
    if (s.deezerID != null) return `dz_${String(s.deezerID)}`;
    const norm = (x) => String(x || '').toLowerCase().trim().replace(/\s+/g, ' ');
    return `na_${norm(s.songName)}__${norm(s.artist)}`;
  };

  // Seed selection with all visible songs
  const seedSelectedAll = useCallback((songs) => {
    const next = new Set();
    songs.forEach((s) => next.add(stableKey(s)));
    setSelected(next);
  }, []);

  // Parse Deezer preview expiry for logging + validation
  function parsePreviewExpiry(url) {
    if (!url || typeof url !== 'string')
      return { exp: null, now: Math.floor(Date.now() / 1000), ttl: null };
    try {
      const qs = url.split('?')[1] || '';
      const params = new URLSearchParams(qs);
      const hdnea = params.get('hdnea') || '';
      const m = /exp=(\d+)/.exec(hdnea);
      const now = Math.floor(Date.now() / 1000);
      if (!m) return { exp: null, now, ttl: null };
      const exp = parseInt(m[1], 10);
      return { exp, now, ttl: exp - now };
    } catch {
      return { exp: null, now: Math.floor(Date.now() / 1000), ttl: null };
    }
  }

  function isPreviewValid(url) {
    const { ttl } = parsePreviewExpiry(url);
    if (ttl === null) return true;
    return ttl > 60;
  }

  function msSince(d) {
    if (!d) return Number.POSITIVE_INFINITY;
    const t = typeof d === 'string' ? Date.parse(d) : d;
    if (Number.isNaN(t)) return Number.POSITIVE_INFINITY;
    return Date.now() - t;
  }

  const REFRESH_COOLDOWN_MS = 10 * 60 * 1000; // 10 minutes

  // ===== Network ops =====
  const rehydrateSong = async (song) => {
    const key = stableKey(song);
    try {
      const effectiveUserID = userID || (isCypressEnv ? 'e2e-user' : null);
      if (!effectiveUserID || !song) return;
      if (rehydrateAvailableRef.current === false) return;

      if (recentlyDone(key)) {
        console.log('[Rankings] rehydrateSong skipped (recently done)', { key });
        return;
      }

      if (rehydratingRef.current.has(key)) {
        console.log('[Rankings] rehydrateSong skipped (already in-flight)', {
          key,
          song: { n: song.songName, a: song.artist },
        });
        return;
      }
      rehydratingRef.current.add(key);

      const endpoint = joinUrl(API_ROOT, 'user-songs', 'rehydrate');

      const ttlInfo = parsePreviewExpiry(song.previewURL);
      console.log('[Rankings] rehydrateSong POST', {
        endpoint,
        song: { id: song._id, deezerID: song.deezerID, name: song.songName, artist: song.artist },
        previewTTL: ttlInfo,
      });

      const res = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userID: effectiveUserID,
          songId: song._id,
          fallbackDeezerID: song.deezerID,
          songName: song.songName,
          artist: song.artist,
        }),
      });

      if (!res.ok) {
        const txt = await res.text();
        console.warn('[Rankings] rehydrateSong FAILED', { status: res.status, body: txt });
        recentlyDoneRef.current.set(key, Date.now());
        if (res.status === 404) {
          rehydrateAvailableRef.current = false;
        }
        throw new Error(`rehydrate failed ${res.status} ${txt}`);
      }

      rehydrateAvailableRef.current = true;

      const updated = await res.json();

      const matches = (s) =>
        (s._id && updated._id && String(s._id) === String(updated._id)) ||
        (!!s.deezerID && !!updated.deezerID && String(s.deezerID) === String(updated.deezerID)) ||
        (s.songName === song.songName && s.artist === song.artist);

      setEnrichedSongs((prev) => prev.map((s) => (matches(s) ? { ...s, ...updated } : s)));
      setFilteredSongs((prev) => prev.map((s) => (matches(s) ? { ...s, ...updated } : s)));

      const audioEl = audioRefs.current.get(key);
      if (audioEl && updated.previewURL) {
        audioEl.src = updated.previewURL;
        audioEl.load();
      }

      recentlyDoneRef.current.set(key, Date.now());

      console.log('[Rankings] rehydrateSong OK', {
        song: { id: song._id, name: song.songName, artist: song.artist },
        updatedPreviewTTL: parsePreviewExpiry(updated.previewURL),
        updatedDeezerID: updated.deezerID,
        lastDeezerRefresh: updated.lastDeezerRefresh,
      });
    } catch (e) {
      console.warn('[Rankings] Rehydrate error:', e);
    } finally {
      rehydratingRef.current.delete(key);
    }
  };

  // ===== Initial fetch =====
  useEffect(() => {
    if ((userID || isCypressEnv) && !applied) {
      console.log('Initial fetch triggered for /rankings');
      handleApply({ genre: 'any', subgenre: 'any', decade: 'all decades' });
    }
  }, [userID, applied]);

  // ===== “Show immediately, fix in background once” =====
  const enrichAndFilterSongs = useCallback(() => {
    if (!applied || !Array.isArray(rankedSongs)) return;

    setEnrichedSongs(rankedSongs);
    setFilteredSongs(rankedSongs);
    setIsFetching(false);

    try {
      let valid = 0, expired = 0, missing = 0;
      const samples = [];
      rankedSongs.forEach((s, i) => {
        if (!s.previewURL) {
          missing++;
          if (samples.length < 5)
            samples.push({ i, name: s.songName, artist: s.artist, reason: 'no previewURL' });
        } else if (isPreviewValid(s.previewURL)) {
          valid++;
        } else {
          expired++;
          if (samples.length < 5) {
            const { ttl, exp, now } = parsePreviewExpiry(s.previewURL);
            samples.push({ i, name: s.songName, artist: s.artist, ttl, exp, now, reason: 'expired' });
          }
        }
      });
      console.log('[Rankings] Snapshot after fetch:', { valid, expired, missing, sample: samples });
    } catch (e) {
      console.log('[Rankings] Snapshot logging error:', e);
    }

    if (didRunFixRef.current) return;
    didRunFixRef.current = true;

    const url = joinUrl(API_ROOT, 'user-songs', 'deezer-info');

    const candidates = rankedSongs.filter((s) => !s.deezerID || !s.albumCover || !s.previewURL);
    console.log('[Rankings] Background fix pass: candidates', {
      total: rankedSongs.length,
      candidates: candidates.length,
      sample: candidates.slice(0, 5).map((s) => ({
        name: s.songName, artist: s.artist, deezerID: s.deezerID, hasCover: !!s.albumCover, hasPreview: !!s.previewURL,
      })),
    });

    const BATCH_SIZE = 10;
    const CONCURRENCY = 2;

    let cursor = 0;
    let active = 0;
    let cancelled = false;

    const runNext = () => {
      if (cancelled) return;
      if (cursor >= candidates.length && active === 0) return;

      while (active < CONCURRENCY && cursor < candidates.length) {
        const slice = candidates.slice(cursor, cursor + BATCH_SIZE);
        cursor += BATCH_SIZE;
        active += 1;

        console.log('[Rankings] deezer-info POST', { url, sliceCount: slice.length });

        fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ songs: slice }),
        })
          .then(async (r) => {
            if (!r.ok) throw new Error(`deezer-info ${r.status}`);
            const batch = await r.json();
            const list = Array.isArray(batch) ? batch : [];
            console.log('[Rankings] deezer-info OK', { returned: list.length });

            setEnrichedSongs((prev) =>
              prev.map((s) => {
                const repl = list.find(
                  (b) =>
                    (b._id && s._id && String(b._id) === String(s._id)) ||
                    (!!b.deezerID && String(b.deezerID) === String(s.deezerID)) ||
                    (b.songName === s.songName && b.artist === s.artist)
                );
                return repl ? { ...s, ...repl } : s;
              })
            );
            setFilteredSongs((prev) =>
              prev.map((s) => {
                const repl = list.find(
                  (b) =>
                    (b._id && s._id && String(b._id) === String(s._id)) ||
                    (!!b.deezerID && String(b.deezerID) === String(s.deezerID)) ||
                    (b.songName === s.songName && b.artist === s.artist)
                );
                return repl ? { ...s, ...repl } : s;
              })
            );
          })
          .catch((err) => {
            console.log('[Rankings] deezer-info error (ignored, UI will self-heal on play)', err?.message || err);
          })
          .finally(() => {
            active -= 1;
            runNext();
          });
      }
    };

    runNext();

    return () => {
      cancelled = true;
    };
  }, [applied, rankedSongs]);

  useEffect(() => {
    return enrichAndFilterSongs();
  }, [enrichAndFilterSongs]);

  // ===== Auto rehydrate only when expired + cooldown =====
  useEffect(() => {
    if (!Array.isArray(filteredSongs) || filteredSongs.length === 0) return;
    if (autoInitRef.current) return;
    autoInitRef.current = true;
    if (rehydrateAvailableRef.current === false) return;

    filteredSongs.forEach((s) => {
      if (!s.previewURL) return;
      const key = stableKey(s);
      if (rehydratingRef.current.has(key) || recentlyDone(key)) return;
      const { ttl } = parsePreviewExpiry(s.previewURL);

      if (!isPreviewValid(s.previewURL) && msSince(s.lastDeezerRefresh) > REFRESH_COOLDOWN_MS) {
        console.log('[Rankings] AUTO rehydrate (expired + cooldown)', {
          name: s.songName, artist: s.artist, deezerID: s.deezerID, ttl, lastDeezerRefresh: s.lastDeezerRefresh,
        });
        rehydrateSong(s);
      }
    });
  }, [filteredSongs]);

  // Keep volume in sync
  useEffect(() => {
    audioRefs.current.forEach((audio) => {
      if (audio) audio.volume = volume;
    });
  }, [volume, filteredSongs]);

  // ===== UI actions =====

  // TEST-ONLY: Allow unit tests to inject ranked songs without hitting network
  const getTestRanked = () => {
    try {
      if (typeof window !== 'undefined' && Array.isArray(window.__TEST_RANKED__)) {
        return window.__TEST_RANKED__;
      }
    } catch {}
    return null;
  };

  const handleApply = async (filters) => {
    const effectiveUserID = userID || (isCypressEnv ? 'e2e-user' : null);
    if (!effectiveUserID) {
      console.log('No userID available, skipping fetch');
      return;
    }

    didRunFixRef.current = false;

    setShowFilter(false);
    setEnrichedSongs([]);
    setFilteredSongs([]);
    setIsFetching(true);
    setSelectedGenre(filters.genre);
    setSelectedSubgenre(filters.subgenre);
    setLastAppliedFilters({ genre: filters.genre, subgenre: filters.subgenre });

    try {
      // TEST-ONLY injection path (skips network)
      const injected = getTestRanked();
      if (injected) {
        setApplied(true);
        setIsFetching(false);
        setEnrichedSongs(injected);
        setFilteredSongs(injected);
        return;
      }

      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Fetch timeout')), 60000)
      );
      await Promise.race([
        // ⬆️ Respect current filters passed from SongFilter
        fetchRankedSongs({
          userID: effectiveUserID,
          genre: filters?.genre ?? 'any',
          subgenre: filters?.subgenre ?? 'any',
        }),
        timeoutPromise,
      ]);
      setApplied(true);
    } catch (error) {
      console.error('handleApply error:', error);
      setApplied(true);
      setFilteredSongs([]);
    }
  };

  async function onExportClick() {
    const decision = await ensureSpotifyConnected(AUTH_ROOT);
    if (decision.shouldRedirect) {
      window.location.href = decision.to;
      return;
    }
    // Connected → inline selection mode
    seedSelectedAll(sortedSongs);
    setExportSuccessUrl('');
    setSelectionMode(true);
  }

  const onCancelSelection = () => {
    setSelectionMode(false);
    setSelected(new Set());
    setPlaylistName('');
    setPlaylistDescription('');
    setExporting(false);
    setExportSuccessUrl('');
  };

  const doExport = async () => {
    if (exporting) return;

    const chosen = sortedSongs.filter((s) => selected.has(stableKey(s)));
    if (chosen.length === 0) return;

    // default name (use your existing genre/subgenre rule; fall back to util if you added it)
    const defaultNameParts = [];
    if (selectedGenre !== 'any') defaultNameParts.push(selectedGenre);
    if (selectedSubgenre !== 'any') defaultNameParts.push(selectedSubgenre);
    const defaultName =
      defaultNameParts.length > 0
        ? `${defaultNameParts.join(' ')} Playlist`
        : 'Melodex Playlist';

    // Build URIs for the current stub path (uses cached spotifyUri if present; otherwise dz/_id fallback)
    const stubUris = chosen
      .filter((s) => s && (s.spotifyUri || s.deezerID || s._id))
      .map((s) => s.spotifyUri || `spotify:track:${s.deezerID || s._id}`);

    // Also include a rich items array to support the real mapping path later
    const items = chosen.map((s) => ({
      deezerID: s.deezerID ?? s._id ?? null,
      songName: s.songName,
      artist: s.artist,
      isrc: s.isrc ?? null,
      spotifyUri: s.spotifyUri ?? null, // cached hit if you have it
      ranking: s.ranking ?? null,
    }));

    const payload = {
      name: (playlistName || '').trim() || defaultName,
      description: (playlistDescription || '').trim(),
      // keep both so tests + future real mapping are happy:
      uris: stubUris,           // legacy/stub consumers
      __testUris: stubUris,     // integration tests use this short-circuit
      items,                    // real mapping path will use this
      // include filters if your backend reads them (optional):
      // filters: { genre: selectedGenre, subgenre: selectedSubgenre }
    };

    // expose for Cypress when present
    if (isCypressEnv && typeof window !== 'undefined') {
      window.__LAST_EXPORT_PAYLOAD__ = payload;
    }

    try {
      setExporting(true);

      // ✅ fix endpoint path to match backend/tests
      const res = await fetch(`${API_ROOT}/playlist/export`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(payload),
      });

      if (!res.ok) throw new Error(`Export failed ${res.status}`);

      const { ok, playlistUrl } = await res.json();

      if (ok && playlistUrl) {
        setExportSuccessUrl(playlistUrl);
        try {
          window.open(playlistUrl, '_blank', 'noopener');
        } catch {}
      }
    } catch (e) {
      console.error('Export error:', e);
    } finally {
      setExporting(false);
    }
  };


  const toggleFilter = () => setShowFilter((prev) => !prev);

  const getRankPositions = (songs) => {
    if (!Array.isArray(songs)) {
      console.error('getRankPositions: songs is not an array', songs);
      return [];
    }
    const sortedSongs = [...songs].sort((a, b) => {
      if (typeof a.ranking !== 'number' || typeof b.ranking !== 'number') {
        console.error('Invalid ranking value', a, b);
        return 0;
      }
      return b.ranking - a.ranking;
    });
    const positions = [];
    let currentRank = 1;
    let previousRanking = null;

    sortedSongs.forEach((song) => {
      if (previousRanking === null || song.ranking !== previousRanking) {
        positions.push(currentRank);
        currentRank += 1;
      } else {
        positions.push(positions[positions.length - 1]);
      }
      previousRanking = song.ranking;
    });

    return positions;
  };

  // ===== Render =====
  const sortedSongs = [...filteredSongs].sort((a, b) => b.ranking - a.ranking);
  const rankPositions = getRankPositions(sortedSongs);
  const zeroSelected = selectionMode && selected.size === 0;

  return (
    <div className="rankings-container" style={{ maxWidth: '1200px', width: '100%' }}>
      <div
        className={`filter-container ${showFilter ? 'visible' : 'hidden'}`}
        style={{ width: '550px', margin: '0 auto' }}
      >
        <SongFilter onApply={handleApply} isRankPage={false} onHide={toggleFilter} />
      </div>

      <div
        style={{
          display: 'flex',
          justifyContent: 'center',
          margin: '0',
          transition: 'transform 0.3s ease',
          transform: showFilter ? 'translateY(0.5rem)' : 'translateY(0)',
        }}
      >
        <button
        className="filter-toggle"
        data-testid="filter-toggle"
        aria-label="Toggle filters"
        onClick={toggleFilter}>
        <svg
            width="20"
            height="20"
            viewBox="0 0 20 20"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <rect y="4" width="20" height="2" rx="1" fill="#bdc3c7" className="filter-line" />
            <rect y="9" width="20" height="2" rx="1" fill="#bdc3c7" className="filter-line" />
            <rect y="14" width="20" height="2" rx="1" fill="#bdc3c7" className="filter-line" />
          </svg>
        </button>
      </div>

      {loading || isFetching ? (
        <div
          style={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            minHeight: '50vh',
          }}
        >
          <div
            style={{
              border: '4px solid #ecf0f1',
              borderTop: '4px solid #3498db',
              borderRadius: '50%',
              width: '40px',
              height: '40px',
              animation: 'spin 1s linear infinite',
            }}
          ></div>
          <p style={{ marginTop: '1rem', fontSize: '1.2em', color: '#7f8c8d', fontWeight: '600' }}></p>
        </div>
      ) : applied ? (
        <div style={{ width: '100%', maxWidth: '1200px', margin: '0 auto' }}>
          <h2 style={{ textAlign: 'center', color: '#141820', marginBottom: '1.0rem', marginTop: '4rem' }}>
            {selectionMode
              ? 'Export to Spotify'
              : (selectedSubgenre !== 'any'
                  ? selectedSubgenre
                  : selectedGenre !== 'any'
                  ? selectedGenre
                  : '') + ' Rankings'}
          </h2>

          {/* Live selection summary (AC-03.2) */}
          {selectionMode && (
            <div
              data-testid="selection-summary"
              /* also expose a stable 'selected-count' node the tests can read directly */
              aria-live="polite"
              data-count={selected?.size ?? 0}
              style={{ textAlign: 'center', fontSize: '0.95rem', color: '#7f8c8d', marginTop: '-0.5rem', marginBottom: '0.75rem' }}
            >
              Selected: {selected?.size ?? 0}
            </div>
          )}

          {/* Inline selection controls / CTA */}
          <div style={{ display: 'flex', justifyContent: 'center', marginBottom: '1.25rem', gap: '0.75rem' }}>
            {!selectionMode ? (
              <button
                onClick={onExportClick}
                data-testid="export-spotify-cta"
                /* alias for tests that expect 'enter-selection' */
                aria-describedby="enter-selection"
                aria-label="Export ranked songs to Spotify"
                style={{ padding: '0.6rem 1rem', fontWeight: 600, borderRadius: 8, border: '1px solid #3498db' }}
              >
                Export to Spotify
              </button>
            ) : (
              <form
                onSubmit={(e) => {
                  e.preventDefault();
                  if (!zeroSelected) doExport();
                }}
                style={{ display: 'grid', gridTemplateColumns: '1fr 1fr auto auto', gap: '0.5rem', alignItems: 'center', width: '100%', maxWidth: 900 }}
              >
                <input
                  type="text"
                  name="playlistName"
                  placeholder="Playlist name"
                  value={playlistName}
                  onChange={(e) => setPlaylistName(e.target.value)}
                  aria-label="Playlist name"
                  style={{ padding: '0.5rem', borderRadius: 8, border: '1px solid #ddd' }}
                />
                <textarea
                  name="playlistDescription"
                  placeholder="Description (optional)"
                  value={playlistDescription}
                  onChange={(e) => setPlaylistDescription(e.target.value)}
                  aria-label="Description"
                  rows={1}
                  style={{ padding: '0.5rem', borderRadius: 8, border: '1px solid #ddd', resize: 'vertical' }}
                />

                {/* Empty-selection hint */}
                {zeroSelected && (
                  <p
                    data-testid="export-hint-empty"
                    role="alert"
                    aria-live="polite"
                    style={{ margin: 0, fontSize: '0.9rem', opacity: 0.8, justifySelf: 'end' }}
                  >
                    Select at least one song to export.
                  </p>
                )}

                <button
                  type="submit"
                  data-testid="export-confirm"
                  disabled={zeroSelected || exporting}
                  style={{
                    padding: '0.6rem 1rem',
                    fontWeight: 600,
                    borderRadius: 8,
                    border: '1px solid #2ecc71',
                    opacity: zeroSelected || exporting ? 0.6 : 1,
                    cursor: zeroSelected || exporting ? 'not-allowed' : 'pointer',
                  }}
                >
                  {exporting ? 'Exporting…' : 'Export'}
                </button>

                <button
                  type="button"
                  onClick={onCancelSelection}
                  data-testid="export-cancel"
                  /* alias for tests that expect 'exit-selection' */
                  aria-describedby="exit-selection"
                  aria-label="Cancel selection mode"
                  style={{ padding: '0.6rem 1rem', borderRadius: 8, border: '1px solid #aaa' }}
                >
                  Cancel
                </button>
              </form>
            )}
          </div>

          {/* Progress readout (UI-005 scaffold) */}
          {selectionMode && exportState !== ExportState.Idle && (
            <div data-testid="export-progress" style={{ textAlign: 'center', marginTop: '-0.5rem', marginBottom: '0.75rem', color: '#7f8c8d' }}>
              {exportState === ExportState.Validating && 'Validating…'}
              {exportState === ExportState.Creating && 'Creating playlist…'}
              {exportState === ExportState.Adding && 'Adding tracks…'}
              {exportState === ExportState.Success && 'Done!'}
              {exportState === ExportState.Error && `Error: ${exportError || 'Something went wrong'}`}
            </div>
          )}

          {exportSuccessUrl && (
            <p style={{ textAlign: 'center', marginBottom: '1rem' }}>
              Playlist created:{' '}
              {(() => {
                const links = buildDeepLink(null, exportSuccessUrl);
                return (
                  <a
                    href={links.web}
                    target="_blank"
                    rel="noopener noreferrer"
                    data-testid="export-success-link"
                  >
                    Open in Spotify
                  </a>
                );
              })()}
            </p>
          )}

          {filteredSongs.length === 0 ? (
            <p style={{ textAlign: 'center', fontSize: '1.2em', color: '#7f8c8d' }}>
              No ranked songs yet for this filter.
            </p>
          ) : (
            <ul
              style={{
                listStyle: 'none',
                padding: 0,
                display: 'grid',
                gap: '1.5rem',
                gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))',
                width: '100%',
              }}
            >
              {sortedSongs.map((song, index) => {
                const k = stableKey(song);
                const isChecked = selected.has(k);
                return (
                  <li
                  data-testid="song-card"
                    key={k}
                    className="song-box"
                    style={{
                      background: 'white',
                      borderRadius: '12px',
                      padding: '1.5rem',
                      boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)',
                      display: 'flex',
                      alignItems: 'center',
                      gap: '1rem',
                      position: 'relative',
                    }}
                  >
                    {/* Inline selection checkbox (left side) */}
                    {selectionMode && (
                      <input
                        type="checkbox"
                        data-testid={`song-checkbox-${k}`}
                        checked={isChecked}
                        onChange={(e) => {
                          const next = new Set(selected);
                          if (e.target.checked) next.add(k);
                          else next.delete(k);
                          setSelected(next);
                        }}
                        aria-label={`Select ${song.songName} by ${song.artist}`}
                        style={{ transform: 'scale(1.2)' }}
                      />
                    )}
                    <span
                      style={{
                        fontSize: '1.5rem',
                        fontWeight: '700',
                        color: '#3498db',
                        minWidth: '2rem',
                        textAlign: 'center',
                      }}
                    >
                      {rankPositions[index]}
                    </span>

                    <img
                      src={song.albumCover || '/placeholder-cover.png'}
                      alt="Album Cover"
                      style={{ width: '80px', height: '80px', borderRadius: '8px' }}
                    />

                    <div style={{ flex: 1 }}>
                      <p
                        style={{
                          fontSize: '1.1rem',
                          fontWeight: '600',
                          color: '#141820',
                          margin: '0',
                        }}
                      >
                        {song.songName}
                      </p>
                      <p style={{ fontSize: '1rem', color: '#7f8c8d', margin: '0.25rem 0' }}>
                        {song.artist}
                      </p>
                      <p style={{ fontSize: '0.9rem', color: '#3498db', margin: '0' }}>
                        Score: {song.ranking}
                      </p>

                      {song.previewURL && isPreviewValid(song.previewURL) ? (
                        <>
                          <audio
                            ref={(el) => {
                              if (el) audioRefs.current.set(k, el);
                              else audioRefs.current.delete(k);
                            }}
                            controls
                            src={song.previewURL}
                            className="custom-audio-player"
                            style={{ marginTop: '0.5rem' }}
                            onVolumeChange={(e) => setVolume(e.target.volume)}
                            onPlay={(e) => {
                              if (playingAudioRef && playingAudioRef !== e.target) {
                                playingAudioRef.pause();
                              }
                              setPlayingAudioRef(e.target);
                            }}
                            onError={(e) => {
                              const { ttl, exp, now } = parsePreviewExpiry(song.previewURL);
                              console.log(
                                '[Rankings] <audio> onError → rehydrate (likely expired / fetch fail)',
                                {
                                  name: song.songName,
                                  artist: song.artist,
                                  deezerID: song.deezerID,
                                  ttl,
                                  exp,
                                  now,
                                }
                              );
                              e.currentTarget.style.display = 'none';
                              const overlay = e.currentTarget.nextElementSibling;
                              if (overlay) overlay.style.display = 'block';
                              rehydrateSong(song);
                            }}
                            onCanPlay={(e) => {
                              console.log('[Rankings] <audio> onCanPlay', {
                                name: song.songName,
                                artist: song.artist,
                                ttl: parsePreviewExpiry(song.previewURL),
                              });
                              e.currentTarget.style.display = 'block';
                              const overlay = e.currentTarget.nextElementSibling;
                              if (overlay) overlay.style.display = 'none';
                            }}
                          />
                          {/* overlay during rehydrate */}
                          <span
                            style={{
                              display: 'none',
                              color: '#e74c3c',
                              background: 'rgba(255,255,255,0.9)',
                              padding: '0.25rem 0.5rem',
                              borderRadius: '6px',
                              fontSize: '0.9rem',
                              position: 'absolute',
                              top: '50%',
                              left: '50%',
                              transform: 'translate(-50%, -50%)',
                              boxShadow: '0 2px 6px rgba(0,0,0,0.08)',
                            }}
                          >
                            Refreshing preview…
                          </span>
                        </>
                      ) : (
                        <span
                          style={{
                            display: 'block',
                            color: '#e74c3c',
                            fontSize: '0.9rem',
                            marginTop: '0.5rem',
                          }}
                        >
                          {/* No preview available */}
                        </span>
                      )}
                    </div>
                  </li>
                );
              })}
            </ul>
          )}
        </div>
      ) : (
        <div
          style={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            minHeight: '50vh',
          }}
        >
          <div
            style={{
              border: '4px solid #ecf0f1',
              borderTop: '4px solid #3498db',
              borderRadius: '50%',
              width: '40px',
              height: '40px',
              animation: 'spin 1s linear infinite',
            }}
          ></div>
          <p style={{ marginTop: '1rem', fontSize: '1.2em', color: '#7f8c8d', fontWeight: '600' }}>
            Loading user data...
          </p>
        </div>
      )}
    </div>
  );
};

export default Rankings;
