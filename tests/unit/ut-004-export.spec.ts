// tests/unit/export/ut-004-mapping.spec.ts
// @ts-nocheck
import { describe, it, expect, vi } from 'vitest';
import { mapDeezerToSpotifyUris, buildCreatePayload } from '../../melodex-front-end/src/utils/spotifyExport';

const mkItem = (over = {}) => ({
  deezerId: 'dz1',
  title: 'Song A',
  artist: 'Artist A',
  isrc: 'US-AAA-00-00001',
  removed: false,
  skipped: false,
  rank: 1,
  ...over,
});

describe('UT-004-Export — Deezer → Spotify mapping', () => {
  it('ISRC lookup preferred', async () => {
    const items = [mkItem(), mkItem({ deezerId: 'dz2', isrc: 'US-AAA-00-00002', rank: 2 })];

    const search = vi.fn(async (q) => {
      if (q.isrc === 'US-AAA-00-00001') return { uri: 'spotify:track:111' };
      if (q.isrc === 'US-AAA-00-00002') return { uri: 'spotify:track:222' };
      return null;
    });

    const { uris } = await mapDeezerToSpotifyUris(items, search);
    expect(uris).toEqual(['spotify:track:111', 'spotify:track:222']);
    expect(search.mock.calls.every(([q]) => 'isrc' in q)).toBe(true);
  });

  it('fallback to title+artist when ISRC missing', async () => {
    const items = [mkItem({ isrc: null, title: 'Hello', artist: 'World' })];
    const search = vi.fn(async (q) => (q.title === 'hello' && q.artist === 'world' ? { uri: 'spotify:track:999' } : null));
    const { uris } = await mapDeezerToSpotifyUris(items, search);
    expect(uris).toEqual(['spotify:track:999']);
  });

  it('normalization applied (case/space)', async () => {
    const items = [mkItem({ isrc: null, title: '  The  Killing Moon ', artist: 'ECHO &  The   BUNNYMEN' })];
    const search = vi.fn(async (q) => (q.title === 'the killing moon' && q.artist === 'echo & the bunnymen' ? { uri: 'spotify:track:tkm' } : null));
    const { uris } = await mapDeezerToSpotifyUris(items, search);
    expect(uris).toEqual(['spotify:track:tkm']);
  });

  it('dedup same URI and preserve first occurrence rank order', async () => {
    const items = [
      mkItem({ deezerId: 'dz1', isrc: 'X1', rank: 1 }),
      mkItem({ deezerId: 'dz2', isrc: 'X2', rank: 2 }),
      mkItem({ deezerId: 'dz3', isrc: 'X1', rank: 3 }) // maps to same as dz1
    ];
    const search = vi.fn(async (q) => {
      if (q.isrc === 'X1') return { uri: 'spotify:track:SAME' };
      if (q.isrc === 'X2') return { uri: 'spotify:track:UNIQ' };
      return null;
    });
    const { uris } = await mapDeezerToSpotifyUris(items, search);
    expect(uris).toEqual(['spotify:track:SAME', 'spotify:track:UNIQ']); // no duplicate
  });

  it('exclude removed/skipped and keep rank order', async () => {
    const items = [
      mkItem({ deezerId: 'a', isrc: 'A', rank: 5 }),
      mkItem({ deezerId: 'b', isrc: 'B', rank: 2, removed: true }),
      mkItem({ deezerId: 'c', isrc: 'C', rank: 9, skipped: true }),
    ];
    const search = vi.fn(async (q) => ({ uri: `spotify:track:${q.isrc}` }));
    const { uris } = await mapDeezerToSpotifyUris(items, search);
    expect(uris).toEqual(['spotify:track:A']); // only the non-removed/non-skipped
  });

  it('unmapped items skipped without failure', async () => {
    const items = [mkItem({ isrc: 'X1' }), mkItem({ isrc: 'X2', deezerId: 'dz2' })];
    const search = vi.fn(async (q) => (q.isrc === 'X2' ? { uri: 'spotify:track:two' } : null));
    const { uris } = await mapDeezerToSpotifyUris(items, search);
    expect(uris).toEqual(['spotify:track:two']);
  });

  it('buildCreatePayload validates and carries name/description/uris', () => {
    const payload = buildCreatePayload({
      name: 'Melodex Playlist 2025-10-03',
      description: 'Generated by Melodex',
      uris: ['spotify:track:1', 'spotify:track:2']
    });
    expect(payload).toEqual({
      name: 'Melodex Playlist 2025-10-03',
      description: 'Generated by Melodex',
      uris: ['spotify:track:1', 'spotify:track:2']
    });
  });
});
